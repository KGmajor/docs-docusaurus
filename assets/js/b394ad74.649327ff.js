"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3967],{9613:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>k});var r=n(9496);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(n),u=a,k=m["".concat(s,".").concat(u)]||m[u]||d[u]||o;return n?r.createElement(k,i(i({ref:t},p),{},{components:n})):r.createElement(k,i({ref:t},p))}));function k(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7159:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var r=n(7605),a=(n(9496),n(9613));const o={},i="Nodes",l={unversionedId:"protocol/js-ceramic/nodes",id:"protocol/js-ceramic/nodes",title:"Nodes",description:"---",source:"@site/docs/protocol/js-ceramic/nodes.md",sourceDirName:"protocol/js-ceramic",slug:"/protocol/js-ceramic/nodes",permalink:"/docs-docusaurus/docs/protocol/js-ceramic/nodes",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"protocol",previous:{title:"Event Fetching",permalink:"/docs-docusaurus/docs/protocol/js-ceramic/networking/event-fetching"},next:{title:"Ceramic API",permalink:"/docs-docusaurus/docs/protocol/js-ceramic/api"}},s={},c=[{value:"Ceramic Nodes",id:"ceramic-nodes",level:2},{value:"IPFS Services",id:"ipfs-services",level:3},{value:"<strong>Ceramic Services</strong>",id:"ceramic-services",level:3},{value:"Timestamp Nodes",id:"timestamp-nodes",level:2},{value:"Implementations",id:"implementations",level:2}],p={toc:c},m="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"nodes"},"Nodes"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"Two types of nodes currently work together to support the Ceramic network."),(0,a.kt)("h2",{id:"ceramic-nodes"},"Ceramic Nodes"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"A Ceramic node is a bundle of services and long-lived processes that support the protocol and provide access to the Ceramic Network. Current implementations bundle and run most all of the following services and sub protocols defined here. This includes the following:"),(0,a.kt)("h3",{id:"ipfs-services"},"IPFS Services"),(0,a.kt)("p",null,"The following services are typically provided to a Ceramic node by a connected IPFS node. These services do not necessarily have to be provided through an IPFS node or all bundled together."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"IPLD Blockstore"),(0,a.kt)("th",{parentName:"tr",align:null},"Stores the underlying IPLD blocks for event streams. Supports block formatting and content addressing."))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Gossipsub"),(0,a.kt)("td",{parentName:"tr",align:null},"Several layers of the libp2p stack are used including GossipSub to query streams and broadcast stream updates in the network.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Kademlia DHT"),(0,a.kt)("td",{parentName:"tr",align:null},"A distributed hash table for content and peer lookup and discovery. The same DHT table is used as the primary IPFS network.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Bitswap"),(0,a.kt)("td",{parentName:"tr",align:null},"Exchange and sync blocks with peers. Allows an event stream to be sycned from one node to another.")))),(0,a.kt)("h3",{id:"ceramic-services"},(0,a.kt)("strong",{parentName:"h3"},"Ceramic Services")),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Pinning"),(0,a.kt)("th",{parentName:"tr",align:null},"Tracks the streams a node wants to store and to receive the latest events for."))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"StateStore"),(0,a.kt)("td",{parentName:"tr",align:null},"Tracks and stores the latest tips for pinned streams and caches stream state.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Networking"),(0,a.kt)("td",{parentName:"tr",align:null},"Runs the stream query and update protocols on Gossipsub and manages peer connections.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"API"),(0,a.kt)("td",{parentName:"tr",align:null},"Provides HTTP API service for connected Ceramic clients to read, write and query streams. Additionally, some node management functions are included.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Timestamping"),(0,a.kt)("td",{parentName:"tr",align:null},"Regularly publishes timestamp proofs and Ceramic time events for a given set of events.")))),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre"},"In the future, node implementations may only provide a subset of services to the network. For example, nodes may be optimized to provide only indexing, long term storage, client APIs etc.\n"))),(0,a.kt)("h2",{id:"timestamp-nodes"},"Timestamp Nodes"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"Timestamping nodes support a small but important subset of the Ceramic protocol. Timestamping is entirely described by ",(0,a.kt)("a",{parentName:"p",href:"https://chainagnostic.org/CAIPs/caip-168"},"CAIP-168 IPLD Timestamp Proof")," and Ceramic Time Events.  Timestamp services aggregate events from streams to be timestamped, construct Merkle proofs, publish transactions and publish timestamp events to the Ceramic Network. Ceramic mainnet currently supports ",(0,a.kt)("inlineCode",{parentName:"p"},"f(bytes32)"),"  timestamp transaction types on Ethereum mainnet. This transaction type is entirely described by the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/ChainAgnostic/namespaces/blob/main/eip155/caip168.md"},(0,a.kt)("inlineCode",{parentName:"a"},"eip155")," namespace")," for CAIP-168. "),(0,a.kt)("h2",{id:"implementations"},"Implementations"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"The following table includes active node implementations:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Node"),(0,a.kt)("th",{parentName:"tr",align:null},"Name"),(0,a.kt)("th",{parentName:"tr",align:null},"Language"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"),(0,a.kt)("th",{parentName:"tr",align:null},"Status"),(0,a.kt)("th",{parentName:"tr",align:null},"Maintainer"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Ceramic"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("a",{parentName:"td",href:"https://github.com/ceramicnetwork/js-ceramic/"},"js-ceramic")),(0,a.kt)("td",{parentName:"tr",align:null},"JavaScript"),(0,a.kt)("td",{parentName:"tr",align:null},"Complete Ceramic implementation. Runs all Ceramic core services, and connects to an IPFS node for all IPFS, libp2p, IPLD services needed."),(0,a.kt)("td",{parentName:"tr",align:null},"Production"),(0,a.kt)("td",{parentName:"tr",align:null},"3Box Labs")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Timestamp"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("a",{parentName:"td",href:"https://github.com/ceramicnetwork/ceramic-anchor-service"},"ceramic-anchor-service")),(0,a.kt)("td",{parentName:"tr",align:null},"JavaScript"),(0,a.kt)("td",{parentName:"tr",align:null},"Complete timestamp services. Supports f(bytes32) and raw transaction types for EVM (EIP-155) blockchains."),(0,a.kt)("td",{parentName:"tr",align:null},"Production"),(0,a.kt)("td",{parentName:"tr",align:null},"3Box Labs")))),(0,a.kt)("p",null,"Longterm Ceramic is targeting multiple implementations of the protocol to support general resilience, robustness and security. Want to work on a node implementation in a new language like Rust or Go? Get in touch on the Forum!"))}d.isMDXComponent=!0}}]);