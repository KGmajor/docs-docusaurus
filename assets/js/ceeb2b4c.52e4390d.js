"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[534],{9613:(e,t,s)=>{s.d(t,{Zo:()=>h,kt:()=>p});var n=s(9496);function r(e,t,s){return t in e?Object.defineProperty(e,t,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[t]=s,e}function a(e,t){var s=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),s.push.apply(s,n)}return s}function o(e){for(var t=1;t<arguments.length;t++){var s=null!=arguments[t]?arguments[t]:{};t%2?a(Object(s),!0).forEach((function(t){r(e,t,s[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(s)):a(Object(s)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(s,t))}))}return e}function i(e,t){if(null==e)return{};var s,n,r=function(e,t){if(null==e)return{};var s,n,r={},a=Object.keys(e);for(n=0;n<a.length;n++)s=a[n],t.indexOf(s)>=0||(r[s]=e[s]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)s=a[n],t.indexOf(s)>=0||Object.prototype.propertyIsEnumerable.call(e,s)&&(r[s]=e[s])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),s=t;return e&&(s="function"==typeof e?e(t):o(o({},t),e)),s},h=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var s=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,h=i(e,["components","mdxType","originalType","parentName"]),m=c(s),d=r,p=m["".concat(l,".").concat(d)]||m[d]||u[d]||a;return s?n.createElement(p,o(o({ref:t},h),{},{components:s})):n.createElement(p,o({ref:t},h))}));function p(e,t){var s=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=s.length,o=new Array(a);o[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[m]="string"==typeof e?e:r,o[1]=i;for(var c=2;c<a;c++)o[c]=s[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,s)}d.displayName="MDXCreateElement"},4086:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var n=s(7605),r=(s(9496),s(9613));const a={},o="Consensus",i={unversionedId:"protocol/js-ceramic/streams/consensus",id:"protocol/js-ceramic/streams/consensus",title:"Consensus",description:"Consensus Model",source:"@site/docs/protocol/js-ceramic/streams/consensus.md",sourceDirName:"protocol/js-ceramic/streams",slug:"/protocol/js-ceramic/streams/consensus",permalink:"/docs-docusaurus/docs/protocol/js-ceramic/streams/consensus",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"protocol",previous:{title:"URI Scheme",permalink:"/docs-docusaurus/docs/protocol/js-ceramic/streams/uri-scheme"},next:{title:"Stream Lifecycle",permalink:"/docs-docusaurus/docs/protocol/js-ceramic/streams/lifecycle"}},l={},c=[{value:"Consensus Model",id:"consensus-model",level:2},{value:"Single stream consensus",id:"single-stream-consensus",level:3},{value:"Cross stream ordering",id:"cross-stream-ordering",level:3},{value:"Risks",id:"risks",level:2},{value:"Late Publishing",id:"late-publishing",level:3}],h={toc:c},m="wrapper";function u(e){let{components:t,...s}=e;return(0,r.kt)(m,(0,n.Z)({},h,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"consensus"},"Consensus"),(0,r.kt)("h2",{id:"consensus-model"},"Consensus Model"),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Event streams rely on a limited conflict resolution or consensus model. Global consensus and ordering is not needed for progress and most decisions are localized to the consuming party of a single event stream. Guarantees are limited, but if any two parties consume the same set of events for a stream, they will arrive at the same state. "),(0,r.kt)("p",null,'The underlying log structure of an event stream allows multiple parallel histories, or branches, to be created resulting in a tree structure. A log or valid event stream is a single tree path from a known "latest" event to the Init Event. Latest events are also referred to as stream "tips". Logs can have multiple tips when there are branches in the log, and the "tip" selection for the canonical log of a stream becomes a consensus problem. '),(0,r.kt)("h3",{id:"single-stream-consensus"},"Single stream consensus"),(0,r.kt)("p",null,"A tip and canonical log for a stream are selected by the following pseudo algorithm and rules: "),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Given a set of tips, traverse each tree path from tip till a commonly shared Time Event or the Init Event. "),(0,r.kt)("li",{parentName:"ol"},"From the shared event, traverse each path in the opposite direction (towards tip) until a Time Event is found (or the end of the log is reached). This set of events are considered conflicting events."),(0,r.kt)("li",{parentName:"ol"},"Given each Time Event, determine the blockheight for the transaction included in the timestamp proof. Select the path with lowest blockheight. If a single path is selected, exit with path and tip selected, otherwise continue. Most cases will terminate here, it will be rare to have the same blockheight."),(0,r.kt)("li",{parentName:"ol"},"If multiple tips have the same blockheight, select the path with the greatest number of events from the last timestamp proof till tip. If single path selected, exit with path and tip selected, otherwise continue."),(0,r.kt)("li",{parentName:"ol"},"If number of events is equal, chooses the event and path which has the smallest CID in binary format (an arbitrary but deterministic choice)")),(0,r.kt)("h3",{id:"cross-stream-ordering"},"Cross stream ordering"),(0,r.kt)("p",null,"It is assumed all timestamp events in a network are committed to the same blockchain, as specified by the ",(0,r.kt)("inlineCode",{parentName:"p"},"chainId")," in the timestamp event. The main Ceramic network commits timestamp proofs to the Ethereum blockchain. "),(0,r.kt)("p",null,"The addition of timestamp events in streams gives some notion of relative global time for all events time-stamped on the same blockchain. This allows events across different streams to be globally ordered if a higher-level protocol requires it. Ceramic events can also be ordered against transactions and state on the blockchain in which it is timestamped. On most secure blockchains you can also reference wall clock time within some reasonable bounds and order events both in and out of the system based on that. "),(0,r.kt)("h2",{id:"risks"},"Risks"),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"late-publishing"},"Late Publishing"),(0,r.kt)("p",null,"Without any global consensus guarantees, all streams and their potential tips are not known by all participants at any point in time. There may be partitions in the networks, existence of local networks, or individual participants may choose to intentionally withhold some events while publishing others. Selective publishing like this may or may not be malicious depending on the context in which the stream is consumed."),(0,r.kt)("p",null,"Consider the following example: A user creates a stream, makes two conflicting updates and timestamps one of them earlier than the other, but only publishes the data of the update that was timestamped later. Now subsequent updates to the stream will be made on top of the second, published update. Every observer will accept these updates as valid since they have not seen the first update. However if the user later publishes the data of the earlier update, the stream will fork back to this update and all of the other updates made to the stream will be invalidated."),(0,r.kt)("p",null,"Most of the time, the potential of an intentional late publishing attack isn't a concern in practice, as streams in Ceramic are generally controlled by a single user, and there's no incentive to attack one's own streams. This would become more of a concern, however, in streams with more sophisticated access control that allowed multiple end users to write into the same stream.  In that case, all users of the stream would need to trust all the other users who have - or have ever had - write access to the stream to not be secretly sitting on timestamped writes that they haven't yet published, or else risk those writes being revealed later on and causing the stream to lose all writes that have occurred since the previously secret write was created."),(0,r.kt)("p",null,"Additionally, note that late publishing may also be used as a deterrent to selling user identities. An identity or account buyer can't know that the seller is not keeping secret events that they will publish after the identity was sold."))}u.isMDXComponent=!0}}]);